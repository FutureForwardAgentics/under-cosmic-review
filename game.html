<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Under Cosmic Review - Venture Bros Guild Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #ffffff;
        }

        canvas {
            display: block;
        }

        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(25, 20, 45, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #9966FF;
            box-shadow: 0 0 20px rgba(153, 102, 255, 0.5);
            z-index: 100;
            min-width: 280px;
        }

        #inquisitorPanel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(25, 20, 45, 0.98);
            padding: 20px;
            border-radius: 12px;
            border: 3px solid #9966FF;
            box-shadow: 0 0 30px rgba(153, 102, 255, 0.8);
            z-index: 150;
            max-width: 600px;
            min-width: 400px;
            text-align: center;
        }

        #inquisitorPanel.cosmic-speaking {
            animation: cosmicPulse 2s ease-in-out;
        }

        @keyframes cosmicPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(153, 102, 255, 0.8); }
            50% { box-shadow: 0 0 50px rgba(153, 102, 255, 1); }
        }

        .inquisitor-title {
            font-size: 14px;
            color: #9966FF;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .inquisitor-text {
            font-size: 16px;
            color: #FFFFFF;
            line-height: 1.4;
            font-style: italic;
        }

        .inquisitor-status {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #FFD700;
            border-radius: 6px;
            padding: 10px;
            margin: 12px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status-label {
            font-size: 10px;
            color: #9966FF;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .status-value {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            text-transform: uppercase;
        }

        .phase-indicator {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-stats {
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #9966FF;
        }

        .stat-label {
            color: #9966FF;
            font-size: 11px;
            text-transform: uppercase;
        }

        .stat-value {
            color: #FFD700;
            font-weight: bold;
        }

        .cosmic-trial {
            color: #4CAF50;
        }

        .cosmic-failure {
            color: #F44336;
        }

        .button {
            background: linear-gradient(135deg, #9966FF 0%, #7744CC 100%);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px 5px 0 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(153, 102, 255, 0.3);
        }

        .button:hover {
            background: linear-gradient(135deg, #AA77FF 0%, #8855DD 100%);
            box-shadow: 0 4px 15px rgba(153, 102, 255, 0.6);
            transform: translateY(-2px);
        }

        .button:active {
            transform: translateY(0);
        }

        .button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
        }

        .button.secondary {
            background: linear-gradient(135deg, #444 0%, #666 100%);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #555 0%, #777 100%);
        }

        #debugPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(25, 20, 45, 0.95);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #9966FF;
            z-index: 100;
            font-size: 10px;
            max-width: 300px;
            max-height: 200px;
            overflow: auto;
        }

        #debugPanel pre {
            color: #9966FF;
            margin: 0;
        }

        .game-info {
            margin: 5px 0;
            font-size: 12px;
        }

        .divider {
            height: 1px;
            background: rgba(153, 102, 255, 0.3);
            margin: 10px 0;
        }

        .ai-indicator {
            color: #FF6B6B;
            font-size: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="gameUI">
        <div class="phase-indicator" id="phaseIndicator">INITIALIZATION</div>

        <div class="divider"></div>

        <div class="game-info">
            <span class="stat-label">Turn:</span>
            <span class="stat-value" id="turnNumber">1</span>
            &nbsp;&nbsp;
            <span class="stat-label">Current Player:</span>
            <span class="stat-value" id="currentPlayer">1</span>
        </div>

        <div class="divider"></div>

        <div class="player-stats">
            <div class="stat-label">Player 1 (You)</div>
            <div>
                <span class="cosmic-trial">‚≠ê Trials: <span id="p1Trials">0</span></span>
                &nbsp;&nbsp;
                <span class="cosmic-failure">üíÄ Failures: <span id="p1Failures">0</span></span>
            </div>
        </div>

        <div class="player-stats">
            <div class="stat-label">Player 2 <span class="ai-indicator">(AI)</span></div>
            <div>
                <span class="cosmic-trial">‚≠ê Trials: <span id="p2Trials">0</span></span>
                &nbsp;&nbsp;
                <span class="cosmic-failure">üíÄ Failures: <span id="p2Failures">0</span></span>
            </div>
        </div>

        <div class="divider"></div>

        <div>
            <button class="button" id="nextPhaseBtn" onclick="handleNextPhase()">Next Phase</button>
            <button class="button secondary" id="passBtn" onclick="handlePass()">Pass</button>
        </div>
    </div>

    <div id="inquisitorPanel">
        <div class="inquisitor-title">‚öñÔ∏è Grand Galactic Inquisitor ‚öñÔ∏è</div>

        <div class="inquisitor-status">
            <div class="status-item">
                <div class="status-label">Phase</div>
                <div class="status-value" id="inquisitorPhase">Initialization</div>
            </div>
            <div class="status-item">
                <div class="status-label">Turn</div>
                <div class="status-value" id="inquisitorTurn">1</div>
            </div>
            <div class="status-item">
                <div class="status-label">Current Player</div>
                <div class="status-value" id="inquisitorPlayer">1</div>
            </div>
        </div>

        <div class="inquisitor-text" id="inquisitorText">
            Cosmic evaluation protocols initializing...
        </div>
    </div>

    <div id="debugPanel">
        <div class="stat-label">Debug Info</div>
        <pre id="debugInfo">{}</pre>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.0.0/dist/pixi.min.js"></script>

    <script>
    // ===== GAME DATA =====

    const GAME_WIDTH = 1200;
    const GAME_HEIGHT = 800;
    const CARD_WIDTH = 80;
    const CARD_HEIGHT = 110;

    const BOSSES = {
        monarch: {
            name: "The Monarch",
            xp: 500,
            treasure: { dramatic: 1 },
            description: "Butterfly-themed schemes"
        },
        drGirlfriend: {
            name: "Dr. Girlfriend",
            xp: 600,
            treasure: { corporate: 1 },
            description: "Seduction and manipulation"
        }
    };

    const HEROES = [
        { name: "Brock Samson", health: 6, treasureType: "government", isEpic: false },
        { name: "Brock Samson", health: 6, treasureType: "government", isEpic: false },
        { name: "Dean Venture", health: 3, treasureType: "science", isEpic: false },
        { name: "Dean Venture", health: 3, treasureType: "science", isEpic: false },
        { name: "Hank Venture", health: 4, treasureType: "dramatic", isEpic: false },
        { name: "Hank Venture", health: 4, treasureType: "dramatic", isEpic: false },
        { name: "Colonel Gentleman", health: 5, treasureType: "government", isEpic: false },
        { name: "Dr. Venture", health: 8, treasureType: "science", isEpic: true },
        { name: "The Monarch", health: 10, treasureType: "dramatic", isEpic: true }
    ];

    const ROOMS = [
        { name: "Death Ray", damage: 3, treasure: { science: 1 } },
        { name: "Death Ray", damage: 3, treasure: { science: 1 } },
        { name: "Dramatic Reveal", damage: 2, treasure: { dramatic: 1 } },
        { name: "Dramatic Reveal", damage: 2, treasure: { dramatic: 1 } },
        { name: "Boardroom", damage: 1, treasure: { corporate: 2 } },
        { name: "Boardroom", damage: 1, treasure: { corporate: 2 } },
        { name: "Secret Lab", damage: 2, treasure: { science: 2 } },
        { name: "Secret Lab", damage: 2, treasure: { science: 2 } },
        { name: "Trap Corridor", damage: 2, treasure: { government: 1 } },
        { name: "Trap Corridor", damage: 2, treasure: { government: 1 } },
        { name: "The Cocoon", damage: 4, treasure: { dramatic: 1 } },
        { name: "Jaw Trap", damage: 5, treasure: { science: 1 } }
    ];

    const INQUISITOR_DIALOGUE = {
        COSMIC_INITIALIZATION: {
            NEUTRAL: [
                "Cosmic evaluation protocols... initializing. Guild antagonists, prepare for assessment.",
                "The cosmic balance requires evaluation. Present your antagonist credentials."
            ]
        },
        PROTAGONIST_EMERGENCE: {
            NEUTRAL: [
                "Protagonists emerge seeking glory. Standard cosmic testing procedures engaged.",
                "Test subjects materializing. Antagonist effectiveness trials... beginning."
            ]
        },
        INSTALLATION_CONSTRUCTION: {
            NEUTRAL: [
                "Present your antagonist installations for cosmic review. Concealment protocols... acceptable.",
                "Construction phase under galactic observation. Your schemes will be... assessed."
            ]
        },
        COSMIC_ATTRACTION: {
            NEUTRAL: [
                "Observing protagonist selection patterns. Cosmic magnetism principles... engaging.",
                "The universe aligns. Protagonists drawn to their designated trials."
            ]
        },
        TRIAL_EXECUTION: {
            NEUTRAL: [
                "Executing cosmic trials. Measuring antagonist effectiveness against protagonist resolve.",
                "The moment of truth arrives. Your schemes face ultimate evaluation."
            ]
        },
        COSMIC_EVALUATION: {
            NEUTRAL: [
                "Tallying cosmic performance metrics. The universe keeps score.",
                "Evaluation cycle complete. Antagonist rankings... updated."
            ]
        },
        FINAL_VERDICT: {
            1: ["Player One demonstrates superior cosmic balance. Authorization granted."],
            2: ["Player Two achieves optimal cosmic superiority. Approval confirmed."]
        }
    };

    // ===== GAME STATE CLASS =====

    class GameState {
        constructor() {
            this.currentPhase = 'COSMIC_INITIALIZATION';
            this.currentPlayer = 1;
            this.turnNumber = 1;
            this.passedPlayers = [];

            this.players = [
                {
                    id: 1,
                    antagonist: null,
                    hand: [],
                    installations: [],
                    cosmicTrials: 0,
                    cosmicFailures: 0,
                    isAI: false
                },
                {
                    id: 2,
                    antagonist: null,
                    hand: [],
                    installations: [],
                    cosmicTrials: 0,
                    cosmicFailures: 0,
                    isAI: true
                }
            ];

            this.protagonistsInCosmos = [];
            this.currentCosmicTrial = [];

            this.decks = {
                protagonists: [],
                installations: []
            };

            this.inquisitorMood = 'EVALUATING';
            this.lastInquisitorComment = '';
            this.gameOver = false;
            this.winner = null;
        }

        shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        drawCard(playerIndex, deckType) {
            const deck = this.decks[deckType];
            if (deck.length === 0) return null;

            const card = deck.pop();
            const cardWithId = { ...card, id: Date.now() + Math.random() };
            this.players[playerIndex].hand.push(cardWithId);
            return cardWithId;
        }

        getTreasureCount(playerIndex, treasureType) {
            const player = this.players[playerIndex];
            let count = 0;

            if (player.antagonist && player.antagonist.treasure[treasureType]) {
                count += player.antagonist.treasure[treasureType];
            }

            player.installations.forEach(installation => {
                if (installation && installation.treasure && installation.treasure[treasureType]) {
                    count += installation.treasure[treasureType];
                }
            });

            return count;
        }

        checkVictory() {
            this.players.forEach((player, index) => {
                if (player.cosmicTrials >= 10) {
                    this.gameOver = true;
                    this.winner = index + 1;
                } else if (player.cosmicFailures >= 5) {
                    this.gameOver = true;
                    this.winner = (index === 0) ? 2 : 1;
                }
            });

            return this.gameOver;
        }

        getCosmicScoreDifferential() {
            const p1Score = this.players[0].cosmicTrials - this.players[0].cosmicFailures;
            const p2Score = this.players[1].cosmicTrials - this.players[1].cosmicFailures;
            return Math.abs(p1Score - p2Score);
        }

        nextPlayer() {
            this.currentPlayer = (this.currentPlayer === 1) ? 2 : 1;
        }

        startNewTurn() {
            this.turnNumber++;
            this.currentPlayer = 1;
            this.passedPlayers = [];
            this.currentCosmicTrial = [];
        }

        getDebugState() {
            return {
                phase: this.currentPhase,
                turn: this.turnNumber,
                player: this.currentPlayer,
                p1: `${this.players[0].cosmicTrials}/${this.players[0].cosmicFailures}`,
                p2: `${this.players[1].cosmicTrials}/${this.players[1].cosmicFailures}`,
                heroes: this.protagonistsInCosmos.length
            };
        }
    }

    // ===== CARD MANAGER CLASS =====

    class CardManager {
        constructor(gameState) {
            this.gameState = gameState;
        }

        initializeDecks(bosses, heroes, rooms) {
            this.gameState.decks.protagonists = [...heroes];
            this.gameState.decks.installations = [...rooms];

            this.gameState.shuffleDeck(this.gameState.decks.protagonists);
            this.gameState.shuffleDeck(this.gameState.decks.installations);
        }

        assignAntagonists(bosses) {
            const bossArray = Object.values(bosses);
            this.gameState.players[0].antagonist = { ...bossArray[0] };
            this.gameState.players[1].antagonist = { ...bossArray[1] };
        }

        dealInitialHands(count) {
            for (let i = 0; i < count; i++) {
                this.gameState.drawCard(0, 'installations');
                this.gameState.drawCard(1, 'installations');
            }
        }

        revealProtagonists(count) {
            for (let i = 0; i < count; i++) {
                const hero = this.gameState.decks.protagonists.pop();
                if (hero) {
                    this.gameState.protagonistsInCosmos.push({ ...hero, id: Date.now() + Math.random() });
                }
            }
        }

        drawPhaseCards(count) {
            for (let i = 0; i < count; i++) {
                this.gameState.drawCard(0, 'installations');
                this.gameState.drawCard(1, 'installations');
            }
        }

        playCard(playerIndex, cardIndex, faceDown = false) {
            const player = this.gameState.players[playerIndex];

            if (cardIndex < 0 || cardIndex >= player.hand.length) {
                return false;
            }

            if (player.installations.length >= 3) {
                return false;
            }

            const card = player.hand.splice(cardIndex, 1)[0];
            card.faceDown = faceDown;
            player.installations.push(card);

            return true;
        }

        revealAllInstallations() {
            this.gameState.players.forEach(player => {
                player.installations.forEach(installation => {
                    installation.faceDown = false;
                });
            });
        }

        processProtagonistAttraction() {
            const attractions = [];

            this.gameState.protagonistsInCosmos.forEach(hero => {
                const p1Treasure = this.gameState.getTreasureCount(0, hero.treasureType);
                const p2Treasure = this.gameState.getTreasureCount(1, hero.treasureType);

                let targetPlayer;
                if (p1Treasure > p2Treasure) {
                    targetPlayer = 0;
                } else if (p2Treasure > p1Treasure) {
                    targetPlayer = 1;
                } else {
                    targetPlayer = Math.random() < 0.5 ? 0 : 1;
                }

                attractions.push({ hero, targetPlayer });
                this.gameState.currentCosmicTrial.push({
                    cardData: hero,
                    cardType: 'hero',
                    targetPlayer
                });
            });

            this.gameState.protagonistsInCosmos = [];
            return attractions;
        }

        clearCosmicTrials() {
            this.gameState.currentCosmicTrial = [];
        }
    }

    // ===== INQUISITOR AI CLASS =====

    class InquisitorAI {
        constructor(gameState) {
            this.gameState = gameState;
            this.recentComments = [];
        }

        providePhaseCommentary(phase) {
            const context = this.evaluateCosmicSituation();
            const phaseDialogue = INQUISITOR_DIALOGUE[phase];

            if (!phaseDialogue) {
                return "Cosmic evaluation continues...";
            }

            let dialoguePool = phaseDialogue[context] || phaseDialogue.NEUTRAL || [];

            if (dialoguePool.length === 0) {
                return "The cosmic evaluation proceeds.";
            }

            const availableComments = dialoguePool.filter(
                comment => !this.recentComments.includes(comment)
            );

            const poolToUse = availableComments.length > 0 ? availableComments : dialoguePool;
            const comment = poolToUse[Math.floor(Math.random() * poolToUse.length)];

            this.recentComments.push(comment);
            if (this.recentComments.length > 5) {
                this.recentComments.shift();
            }

            return comment;
        }

        evaluateCosmicSituation() {
            const scoreDiff = this.gameState.getCosmicScoreDifferential();
            const turnNumber = this.gameState.turnNumber;

            if (turnNumber >= 8) return 'COSMIC_TENSION';
            if (scoreDiff >= 3) return 'DOMINANT_ANTAGONIST';
            if (turnNumber <= 2) return 'EARLY_GAME';
            return 'BALANCED_EVALUATION';
        }

        provideFinalVerdict(winner) {
            const verdicts = INQUISITOR_DIALOGUE.FINAL_VERDICT[winner];
            if (!verdicts || verdicts.length === 0) {
                return `Player ${winner} achieves victory. Status: Approved.`;
            }
            return verdicts[Math.floor(Math.random() * verdicts.length)];
        }
    }

    // ===== AI PLAYER CLASS =====

    class AIPlayer {
        constructor(gameState, playerIndex) {
            this.gameState = gameState;
            this.playerIndex = playerIndex;
        }

        makeDecision(phase) {
            if (phase === 'INSTALLATION_CONSTRUCTION') {
                return this.decideBuildAction();
            }
            return null;
        }

        decideBuildAction() {
            const player = this.gameState.players[this.playerIndex];

            if (player.installations.length >= 3) {
                return { action: 'pass' };
            }

            if (player.hand.length === 0) {
                return { action: 'pass' };
            }

            const cardIndex = this.selectBestCard();

            if (cardIndex >= 0) {
                return { action: 'play', cardIndex };
            }

            return { action: 'pass' };
        }

        selectBestCard() {
            const player = this.gameState.players[this.playerIndex];

            if (player.hand.length === 0) return -1;

            let bestIndex = 0;
            let bestScore = this.evaluateCard(player.hand[0]);

            for (let i = 1; i < player.hand.length; i++) {
                const score = this.evaluateCard(player.hand[i]);
                if (score > bestScore) {
                    bestScore = score;
                    bestIndex = i;
                }
            }

            return bestIndex;
        }

        evaluateCard(card) {
            let score = card.damage || 0;

            if (card.treasure) {
                score += Object.values(card.treasure).reduce((a, b) => a + b, 0);
            }

            return score + Math.random() * 2;
        }
    }

    // ===== PHASE MANAGER CLASS =====

    class PhaseManager {
        constructor(gameState, cardManager, inquisitorAI, aiPlayer) {
            this.gameState = gameState;
            this.cardManager = cardManager;
            this.inquisitor = inquisitorAI;
            this.aiPlayer = aiPlayer;

            this.onPhaseChange = null;
            this.onCommentary = null;
        }

        nextPhase() {
            if (this.inquisitor && this.onCommentary) {
                const commentary = this.inquisitor.providePhaseCommentary(this.gameState.currentPhase);
                this.onCommentary(commentary);
            }

            const phases = [
                'COSMIC_INITIALIZATION',
                'PROTAGONIST_EMERGENCE',
                'INSTALLATION_CONSTRUCTION',
                'COSMIC_ATTRACTION',
                'TRIAL_EXECUTION',
                'COSMIC_EVALUATION'
            ];

            const currentIndex = phases.indexOf(this.gameState.currentPhase);

            if (currentIndex === 0) {
                this.handleCosmicInit();
            } else if (currentIndex === 1) {
                this.handleProtagonistPhase();
            } else if (currentIndex === 2) {
                // Build phase - handled by player actions
            } else if (currentIndex === 3) {
                this.handleBait();
            } else if (currentIndex === 4) {
                this.handleScheme();
            } else if (currentIndex === 5) {
                this.handleEnd();
            }

            if (this.onPhaseChange) {
                this.onPhaseChange(this.gameState.currentPhase);
            }
        }

        handleCosmicInit() {
            this.gameState.currentPhase = 'PROTAGONIST_EMERGENCE';
        }

        handleProtagonistPhase() {
            this.cardManager.revealProtagonists(2);
            this.cardManager.drawPhaseCards(1);

            this.gameState.currentPhase = 'INSTALLATION_CONSTRUCTION';
            this.gameState.currentPlayer = 1;
            this.gameState.passedPlayers = [];
        }

        handleBait() {
            this.cardManager.processProtagonistAttraction();
            this.gameState.currentPhase = 'TRIAL_EXECUTION';
        }

        handleScheme() {
            this.gameState.currentCosmicTrial.forEach(trial => {
                if (trial.cardType === 'hero') {
                    this.processProtagonistTrial(trial.cardData, trial.targetPlayer);
                }
            });

            this.cardManager.clearCosmicTrials();
            this.gameState.checkVictory();

            if (this.gameState.gameOver) {
                if (this.inquisitor && this.onCommentary) {
                    const verdict = this.inquisitor.provideFinalVerdict(this.gameState.winner);
                    this.onCommentary(verdict);
                }
            } else {
                this.gameState.currentPhase = 'COSMIC_EVALUATION';
            }
        }

        processProtagonistTrial(protagonist, playerIndex) {
            const player = this.gameState.players[playerIndex];
            let currentHealth = protagonist.health;

            player.installations.forEach(installation => {
                if (installation && currentHealth > 0) {
                    currentHealth -= (installation.damage || 0);
                }
            });

            if (currentHealth <= 0) {
                player.cosmicTrials += protagonist.isEpic ? 2 : 1;
            } else {
                player.cosmicFailures += protagonist.isEpic ? 2 : 1;
            }
        }

        handleEnd() {
            this.gameState.startNewTurn();

            if (!this.gameState.gameOver) {
                this.gameState.currentPhase = 'PROTAGONIST_EMERGENCE';
            }
        }

        playerBuildAction(playerIndex, cardIndex) {
            if (this.gameState.currentPhase !== 'INSTALLATION_CONSTRUCTION') {
                return false;
            }

            if (playerIndex !== this.gameState.currentPlayer - 1) {
                return false;
            }

            const success = this.cardManager.playCard(playerIndex, cardIndex, true);

            if (success) {
                this.advanceBuildPhase();
            }

            return success;
        }

        playerPass() {
            if (this.gameState.currentPhase !== 'INSTALLATION_CONSTRUCTION') {
                return;
            }

            const currentPlayerIndex = this.gameState.currentPlayer - 1;

            if (!this.gameState.passedPlayers.includes(currentPlayerIndex)) {
                this.gameState.passedPlayers.push(currentPlayerIndex);
            }

            this.advanceBuildPhase();
        }

        advanceBuildPhase() {
            if (this.gameState.passedPlayers.length >= this.gameState.players.length) {
                this.cardManager.revealAllInstallations();
                this.gameState.currentPhase = 'COSMIC_ATTRACTION';

                if (this.onPhaseChange) {
                    this.onPhaseChange(this.gameState.currentPhase);
                }
                return;
            }

            this.gameState.nextPlayer();

            if (this.gameState.players[this.gameState.currentPlayer - 1].isAI) {
                setTimeout(() => this.executeAIAction(), 1000);
            }

            if (this.onPhaseChange) {
                this.onPhaseChange(this.gameState.currentPhase);
            }
        }

        executeAIAction() {
            if (this.gameState.currentPhase !== 'INSTALLATION_CONSTRUCTION') {
                return;
            }

            const decision = this.aiPlayer.makeDecision(this.gameState.currentPhase);

            if (decision.action === 'play') {
                this.playerBuildAction(this.gameState.currentPlayer - 1, decision.cardIndex);
            } else if (decision.action === 'pass') {
                this.playerPass();
            }

            renderGame();
            updateUIElements();
        }

        getPhaseName() {
            const phaseNames = {
                'COSMIC_INITIALIZATION': 'Initialization',
                'PROTAGONIST_EMERGENCE': 'Protagonist Emergence',
                'INSTALLATION_CONSTRUCTION': 'Installation Construction',
                'COSMIC_ATTRACTION': 'Cosmic Attraction',
                'TRIAL_EXECUTION': 'Trial Execution',
                'COSMIC_EVALUATION': 'Cosmic Evaluation'
            };

            return phaseNames[this.gameState.currentPhase] || this.gameState.currentPhase;
        }

        forceNextPhase() {
            const phases = [
                'COSMIC_INITIALIZATION',
                'PROTAGONIST_EMERGENCE',
                'INSTALLATION_CONSTRUCTION',
                'COSMIC_ATTRACTION',
                'TRIAL_EXECUTION',
                'COSMIC_EVALUATION'
            ];

            const currentIndex = phases.indexOf(this.gameState.currentPhase);

            if (currentIndex === phases.length - 1) {
                this.handleEnd();
            } else {
                this.nextPhase();
            }
        }
    }

    // ===== PIXI.JS CARD RENDERING =====

    class PixiCard extends PIXI.Container {
        constructor(cardData, cardType = 'room') {
            super();

            this.cardData = cardData;
            this.cardType = cardType;
            this.isFaceDown = cardData.faceDown || false;
            this.isPlayable = false;

            this.createVisuals();
        }

        createVisuals() {
            this.bg = new PIXI.Graphics();
            this.addChild(this.bg);

            this.border = new PIXI.Graphics();
            this.addChild(this.border);

            this.textContainer = new PIXI.Container();
            this.addChild(this.textContainer);

            this.updateVisuals();
        }

        updateVisuals() {
            this.bg.clear();
            this.border.clear();

            if (this.isFaceDown) {
                this.renderFaceDown();
            } else {
                this.renderFaceUp();
            }
        }

        renderFaceDown() {
            this.bg.rect(0, 0, CARD_WIDTH, CARD_HEIGHT).fill(0x424242);
            this.border.rect(0, 0, CARD_WIDTH, CARD_HEIGHT).stroke({ color: 0xFFFFFF, width: 2 });

            this.textContainer.removeChildren();

            const backText = new PIXI.Text({
                text: 'GUILD',
                style: {
                    fontSize: 14,
                    fill: 0x9966FF,
                    fontWeight: 'bold'
                }
            });
            backText.x = CARD_WIDTH / 2 - backText.width / 2;
            backText.y = CARD_HEIGHT / 2 - backText.height / 2;
            this.textContainer.addChild(backText);
        }

        renderFaceUp() {
            const color = this.getCardColor();

            this.bg.rect(0, 0, CARD_WIDTH, CARD_HEIGHT).fill(color);

            const borderColor = this.isPlayable ? 0xFFD700 : 0xFFFFFF;
            const borderWidth = this.isPlayable ? 3 : 2;

            this.border.rect(0, 0, CARD_WIDTH, CARD_HEIGHT).stroke({ color: borderColor, width: borderWidth });

            this.textContainer.removeChildren();

            const nameText = new PIXI.Text({
                text: this.cardData.name || 'Unknown',
                style: {
                    fontSize: 10,
                    fill: 0xFFFFFF,
                    wordWrap: true,
                    wordWrapWidth: CARD_WIDTH - 10,
                    fontWeight: 'bold'
                }
            });
            nameText.x = 5;
            nameText.y = 5;
            this.textContainer.addChild(nameText);

            if (this.cardData.damage !== undefined) {
                const dmgText = new PIXI.Text({
                    text: `DMG: ${this.cardData.damage}`,
                    style: {
                        fontSize: 12,
                        fill: 0xFFFFFF,
                        fontWeight: 'bold'
                    }
                });
                dmgText.x = 5;
                dmgText.y = CARD_HEIGHT - 20;
                this.textContainer.addChild(dmgText);
            }

            if (this.cardData.health !== undefined) {
                const hpText = new PIXI.Text({
                    text: `HP: ${this.cardData.health}`,
                    style: {
                        fontSize: 12,
                        fill: 0xFFFFFF,
                        fontWeight: 'bold'
                    }
                });
                hpText.x = 5;
                hpText.y = CARD_HEIGHT - 20;
                this.textContainer.addChild(hpText);
            }
        }

        getCardColor() {
            const colors = {
                science: 0x4CAF50,
                dramatic: 0xFF9800,
                corporate: 0x2196F3,
                government: 0x9C27B0
            };

            if (this.cardType === 'hero') {
                return 0xF44336;
            }

            if (this.cardData.treasure) {
                const treasureTypes = Object.keys(this.cardData.treasure);
                if (treasureTypes.length > 0) {
                    return colors[treasureTypes[0]] || 0x333333;
                }
            }

            return 0x333333;
        }

        setPlayable(playable, callback) {
            this.isPlayable = playable;
            this.eventMode = playable ? 'static' : 'none';
            this.cursor = playable ? 'pointer' : 'default';

            if (playable && callback) {
                this.removeAllListeners();
                this.on('pointerdown', callback);
            }

            this.updateVisuals();
        }
    }

    // ===== GAME INSTANCE =====

    let app;
    let gameState;
    let cardManager;
    let phaseManager;
    let inquisitorAI;
    let aiPlayer;
    let gameScene;
    let gameUI = {};

    async function initGame() {
        app = new PIXI.Application();

        await app.init({
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            backgroundColor: 0x1a1a2e,
            antialias: true
        });

        document.body.appendChild(app.canvas);

        gameScene = new PIXI.Container();
        app.stage.addChild(gameScene);

        gameState = new GameState();
        cardManager = new CardManager(gameState);
        inquisitorAI = new InquisitorAI(gameState);
        aiPlayer = new AIPlayer(gameState, 1);
        phaseManager = new PhaseManager(gameState, cardManager, inquisitorAI, aiPlayer);

        cardManager.initializeDecks(BOSSES, HEROES, ROOMS);
        cardManager.assignAntagonists(BOSSES);
        cardManager.dealInitialHands(5);

        phaseManager.onPhaseChange = handlePhaseChange;
        phaseManager.onCommentary = handleInquisitorCommentary;

        initGameUI();
        startGame();
    }

    function initGameUI() {
        const player1Area = new PIXI.Container();
        const player2Area = new PIXI.Container();
        const heroArea = new PIXI.Container();
        const schemeArea = new PIXI.Container();

        gameScene.addChild(player1Area);
        gameScene.addChild(player2Area);
        gameScene.addChild(heroArea);
        gameScene.addChild(schemeArea);

        // Center player areas horizontally
        // Max cards: 1 boss + 3 installations = 4 cards, plus hand cards
        // Lair width: 4 * 80 + 3 * 10 = 350px
        const lairWidth = 4 * (CARD_WIDTH + 10) - 10;
        const playerAreaX = (GAME_WIDTH - lairWidth) / 2;

        player1Area.x = playerAreaX;
        player1Area.y = GAME_HEIGHT - 220;

        player2Area.x = playerAreaX;
        player2Area.y = 50;

        // Hero and scheme areas will be centered dynamically in render functions
        heroArea.y = GAME_HEIGHT / 2 - 100;
        schemeArea.y = GAME_HEIGHT / 2 - 55;

        gameUI = { player1Area, player2Area, heroArea, schemeArea };

        renderGame();
        updateUIElements();
    }

    function renderGame() {
        gameUI.player1Area.removeChildren();
        gameUI.player2Area.removeChildren();
        gameUI.heroArea.removeChildren();
        gameUI.schemeArea.removeChildren();

        renderPlayer(0, gameUI.player1Area);
        renderPlayer(1, gameUI.player2Area);
        renderHeroes();
        renderTrials();
    }

    function renderPlayer(playerIndex, container) {
        const player = gameState.players[playerIndex];

        const handContainer = new PIXI.Container();
        handContainer.y = playerIndex === 0 ? 80 : 0;
        container.addChild(handContainer);

        const lairContainer = new PIXI.Container();
        lairContainer.y = playerIndex === 0 ? 0 : 80;
        container.addChild(lairContainer);

        // Render hand cards (centered to align with lair center)
        const handWidth = player.hand.length * (CARD_WIDTH + 10) - 10;
        const lairWidth = 4 * (CARD_WIDTH + 10) - 10; // Boss + 3 installations max
        const lairCenterX = lairWidth / 2;
        const handOffsetX = lairCenterX - (handWidth / 2);

        player.hand.forEach((card, index) => {
            const cardSprite = new PixiCard(card, 'room');
            cardSprite.x = handOffsetX + index * (CARD_WIDTH + 10);

            if (playerIndex === gameState.currentPlayer - 1 &&
                gameState.currentPhase === 'INSTALLATION_CONSTRUCTION' &&
                !player.isAI) {
                cardSprite.setPlayable(true, () => playCard(playerIndex, index));
            }

            handContainer.addChild(cardSprite);
        });

        // Render lair (boss + installations)
        if (player.antagonist) {
            const bossCard = new PixiCard(player.antagonist, 'boss');
            bossCard.x = 0;
            lairContainer.addChild(bossCard);
        }

        player.installations.forEach((installation, index) => {
            const installCard = new PixiCard(installation, 'room');
            installCard.isFaceDown = installation.faceDown;
            installCard.updateVisuals();
            installCard.x = (index + 1) * (CARD_WIDTH + 10);
            lairContainer.addChild(installCard);
        });
    }

    function renderHeroes() {
        if (gameState.protagonistsInCosmos.length === 0) return;

        // Center heroes
        const heroWidth = gameState.protagonistsInCosmos.length * (CARD_WIDTH + 10) - 10;
        const heroOffsetX = -heroWidth / 2;

        gameState.protagonistsInCosmos.forEach((hero, index) => {
            const heroCard = new PixiCard(hero, 'hero');
            heroCard.x = heroOffsetX + index * (CARD_WIDTH + 10);
            gameUI.heroArea.addChild(heroCard);
        });

        // Center hero area itself
        gameUI.heroArea.x = GAME_WIDTH / 2;
    }

    function renderTrials() {
        if (gameState.currentCosmicTrial.length === 0) return;

        // Center trials
        const trialWidth = gameState.currentCosmicTrial.length * (CARD_WIDTH + 10) - 10;
        const trialOffsetX = -trialWidth / 2;

        gameState.currentCosmicTrial.forEach((trial, index) => {
            const trialCard = new PixiCard(trial.cardData, trial.cardType);
            trialCard.x = trialOffsetX + index * (CARD_WIDTH + 10);
            gameUI.schemeArea.addChild(trialCard);
        });

        // Center scheme area itself
        gameUI.schemeArea.x = GAME_WIDTH / 2;
    }

    function playCard(playerIndex, cardIndex) {
        const success = phaseManager.playerBuildAction(playerIndex, cardIndex);
        if (success) {
            renderGame();
            updateUIElements();
        }
    }

    function handlePhaseChange(newPhase) {
        renderGame();
        updateUIElements();
    }

    function handleInquisitorCommentary(commentary) {
        const panel = document.getElementById('inquisitorPanel');
        const text = document.getElementById('inquisitorText');

        text.textContent = commentary;
        panel.classList.add('cosmic-speaking');

        setTimeout(() => {
            panel.classList.remove('cosmic-speaking');
        }, 3000);
    }

    function updateUIElements() {
        const phaseName = phaseManager.getPhaseName();

        // Update left panel
        document.getElementById('phaseIndicator').textContent = phaseName;
        document.getElementById('turnNumber').textContent = gameState.turnNumber;
        document.getElementById('currentPlayer').textContent = gameState.currentPlayer;
        document.getElementById('p1Trials').textContent = gameState.players[0].cosmicTrials;
        document.getElementById('p1Failures').textContent = gameState.players[0].cosmicFailures;
        document.getElementById('p2Trials').textContent = gameState.players[1].cosmicTrials;
        document.getElementById('p2Failures').textContent = gameState.players[1].cosmicFailures;
        document.getElementById('debugInfo').textContent = JSON.stringify(gameState.getDebugState(), null, 2);

        // Update Inquisitor panel status display
        document.getElementById('inquisitorPhase').textContent = phaseName;
        document.getElementById('inquisitorTurn').textContent = gameState.turnNumber;
        document.getElementById('inquisitorPlayer').textContent = gameState.currentPlayer;
    }

    function startGame() {
        updateUIElements();
        phaseManager.nextPhase();
    }

    function handleNextPhase() {
        phaseManager.forceNextPhase();
        renderGame();
        updateUIElements();
    }

    function handlePass() {
        phaseManager.playerPass();
        renderGame();
        updateUIElements();
    }

    window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
